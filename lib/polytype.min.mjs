// Polytype 0.6.1 â€“ https://github.com/fasttime/Polytype
function t(e,o){const n=H(o);for(const o of n)if(o===e||t(e,o))return!0;return!1}const e=[],o=Function.prototype,n=Map,r=Object,{create:s,defineProperties:c,defineProperty:i,getOwnPropertyDescriptor:a,getOwnPropertyDescriptors:u,getPrototypeOf:l,prototype:f,setPrototypeOf:p}=r,y=Proxy,d=Reflect,{construct:h,get:w,ownKeys:g,set:m}=d,P=Set,b=String,v=Symbol.hasInstance,O=TypeError,_=t=>o.call.bind(t),x=_(o.bind),$=_(o[v]),S=_(o.toString),j=_(f.hasOwnProperty),I=_(f.valueOf),k=(t,e)=>{if(t.has(e)){const t=`Duplicate superclass ${st(e)}`;throw O(t)}},D=t=>{if(!V(t))throw O("Argument is not a function")},L=(...t)=>{if(!t.length)throw O("No superclasses specified");const e=new P,o=new P;for(const n of t){if(k(e,n),!X(n)){const t=`${st(n)} is not a constructor`;throw O(t)}const{prototype:t}=n;if(et(t)){const t=`Property 'prototype' of ${st(n)} is not an object or null`;throw O(t)}e.add(n),null!==t&&o.add(t)}const n=function(t,e){const o=T(t),n=E(t),r=R(e),i=C(t),a=K(i,t,A),u=s(null,{constructor:z(a,!0,!1,!0),class:z(r)}),l=K(u,e,M),f={class:z(o),name:{get:n},prototype:z(l)};return c(i,f),a}(e,o);return function(...t){const e=new P,o=new P;for(const n of t)for(let t of n)for(;!e.has(t);){e.add(t);const n=t.constructor;X(n)&&U(n,o);const r=l(t);if(null===r){const e=a(t,"isPrototypeOf");e&&Z(e.value,"isPrototypeOf")&&(e.value=rt,i(t,"isPrototypeOf",e))}if(!nt(t=r))break}}(e,o),n},M={setPrototypeOf:()=>!1},A={__proto__:M,apply:()=>{throw O("Constructor cannot be invoked without 'new'")}},C=t=>{const e=function(...e){const o=function(t,e){const o=new n;let r,s;const c=t=>{if(r===!t)throw O("Mixed argument styles");r=t};for(const n of e){if(ot(n))throw O("Invalid arguments");let e,r;if(void 0!==n&&nt(e=n.super)){if(c(!0),k(o,e),!t.has(e)){const t=`${st(e)} is not a direct superclass`;throw O(t)}if(r=n.arguments,ot(r)){const t=`Invalid arguments for superclass ${st(e)}`;throw O(t)}}else c(!1),s||(s=t.values()),e=s.next().value,r=n;const i=void 0!==r?F(r):void 0;o.set(e,i)}return o}(t,e),r=new.target;for(const e of t){const t=o.get(e),n=B(e,t,r),s=g(n);for(const t of s)j(this,t)&&delete n[t];c(this,n)}};return p(e,null),e},E=t=>()=>`(${[...t].map(({name:t})=>b(t))})`,F=o.apply.bind((...t)=>t,null),K=(t,e,o)=>{const n=((t,e)=>({__proto__:e,get(e,o,n){const r=t.find(it(o));if(void 0!==r)return w(r,o,n)},has:(e,o)=>t.some(it(o)),set(e,o,n,r){const s=t.find(it(o));return void 0!==s?m(s,o,n,r):(W(r,o,n,!0,!0),!0)}}))([t,...e],o),r=new y(t,n);return at.set(r,e),r},N=(t,e)=>{const o=t=>{const o=t();return p(r,e),o},n=new y(e,{get:(n,r)=>o(()=>w(t,r,e)),set:(n,r,s)=>o(()=>m(t,r,s,e))}),r=s(n);return r},R=t=>W(class{static _(e){D(e);const{prototype:o}=e;if(!t.has(o)){const t=nt(o)?"Property 'prototype' of argument does not match any direct superclass":"Property 'prototype' of argument is not an object";throw O(t)}return N(o,this)}}._,"name","class",!1),T=t=>W(class{static _(e){if(!t.has(e))throw D(e),O("Argument is not a direct superclass");return N(e,this)}}._,"name","class",!1),W=(t,e,o,n=!0,r=!1)=>i(t,e,z(o,n,r,!0)),q=()=>{const t="undefined"==typeof self?global:self;return!t.hasOwnProperty("classes")&&(W(t,"classes",L),W(r,"getPrototypeListOf",G),!0)},z=(t,e,o,n)=>({value:t,writable:e,enumerable:o,configurable:n}),B=(t,o=e,n)=>u(h(t,o,n)),{getPrototypeListOf:G}={getPrototypeListOf:t=>{let e;{const o=l(t);if(null!==o){const t=at.get(o);e=t?[...t]:[o]}else e=[]}return e}},H=t=>{let o=at.get(t);if(!o){const n=l(t);o=null!==n?[n]:e}return o},{[v]:J}=class{static[v](e){Q=!0;try{if(V(this)){const o=$(this,e);if(!Q)return o;if(o||nt(e)&&t(this.prototype,e))return!0}return!1}finally{Q=!1}}};let Q=!1;const U=(t,e)=>{if(Y(t))return!1;if(e.has(t))return!0;e.add(t);const o=H(t);let n=!1;for(const t of o)nt(t)&&U(t,e)&&(n=!0);return n||(t=>W(t,v,J))(t),!0},V=t=>"function"==typeof t,X=t=>{if(V(t)){const e=x(t);W(e,"prototype",null);const o=new y(e,{construct(){return this}});try{return new class extends o{},!0}catch(t){}}return!1},Y=t=>{if(Z(t,"")){const e=a(t,v);if(e&&!e.writable&&!e.enumerable&&!e.configurable){const{value:t}=e;if(Z(t,"[Symbol.hasInstance]"))return!0}}return!1},Z=(t,e)=>{let o;try{o=S(t)}catch(t){return!1}const n=/^function ?(.*)\(\) {\s+\[native code]\s+}/.exec(o);return n&&n[1]===e&&!X(t)},tt=t=>!ct.includes(typeof t),et=t=>void 0===t||tt(t),ot=t=>null===t||tt(t),nt=t=>null!==t&&!et(t),{isPrototypeOf:rt}=class{static isPrototypeOf(e){return!(!nt(e)||!t(I(this),e))}},st=t=>{let e;return V(t)&&(({name:e}=t),null!=e&&(e=b(e)))?e:e=b(t)},ct=["function","object","undefined"],it=t=>e=>t in e,at=new WeakMap;W(L,"name","classes",!1);export{L as classes,q as defineGlobally,G as getPrototypeListOf};